<?xml version="1.0"?>
<!DOCTYPE bindings PUBLIC "-//MOZILLA//DTD XBL V1.0//EN" "http://www.mozilla.org/xbl"
[
<!ENTITY % songbirdDTD SYSTEM "chrome://songbird/locale/songbird.dtd">
%songbirdDTD;
]
>
<!--
/*
 *=BEGIN SONGBIRD GPL
 *
 * This file is part of the Songbird web player.
 *
 * Copyright(c) 2005-2010 POTI, Inc.
 * http://www.songbirdnest.com
 *
 * This file may be licensed under the terms of of the
 * GNU General Public License Version 2 (the ``GPL'').
 *
 * Software distributed under the License is distributed
 * on an ``AS IS'' basis, WITHOUT WARRANTY OF ANY KIND, either
 * express or implied. See the GPL for the specific language
 * governing rights and limitations.
 *
 * You should have received a copy of the GPL along with this
 * program. If not, go to http://www.gnu.org/licenses/gpl.html
 * or write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 *=END SONGBIRD GPL
 */
-->

<bindings
    xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="sb-tabbrowser" extends="chrome://songbird/content/bindings/browser/tabBrowserCompat.xml#tabbrowser-compat">
    <implementation implements="sbITabBrowser">
      <constructor>
          <![CDATA[
        window.gBrowser = this;

        this._platform = Cc["@mozilla.org/system-info;1"]
                           .getService(Ci.nsIPropertyBag2)
                           .getProperty("name");

        Cu.import("resource://app/jsmodules/sbProperties.jsm");
        Cu.import("resource://app/jsmodules/kPlaylistCommands.jsm");
        Cu.import("resource://app/jsmodules/sbLibraryUtils.jsm");
        Cu.import("resource://app/jsmodules/ArrayConverter.jsm");
        Cu.import("resource://gre/modules/XPCOMUtils.jsm");
        Cu.import("resource://app/jsmodules/URLUtils.jsm");

        // we moved the strip container to the tabs binding
        // this must happen before the addProgressListener call below to properly
        // trigger showing the tabstrip when the always show pref is set and
        // there is only one tab at startup
        var strip = document.getAnonymousElementByAttribute(this, "anonid", "strip");
        if (strip && strip.collapsed) {
          // don't collapse the outer box, collapse the inner <tabs> element instead
          strip.collapsed = false;
          this.mStrip.collapsed = true;
        }
        if (this.hasAttribute("tabstrip")) {
          this.mStrip = document.getElementById(this.getAttribute("tabstrip"));
        }

        /* load the tab progress listener object
         * this is used to trigger notifyTabContentChange() / saveTabState()
         * and to set various data remotes on location change, such as toolbar
         * button states and setting <sb-tabbrowser>.loading
         */
        var subscriptLoader = Cc["@mozilla.org/moz/jssubscript-loader;1"]
                                .getService(Ci.mozIJSSubScriptLoader);
        var scope = {};
        subscriptLoader.loadSubScript("chrome://songbird/content/bindings/browser/SBTabProgressListener.js", scope);
        this.webProgressListener = new scope.SBTabProgressListener(this);
        this.addProgressListener(this.webProgressListener,
                                 Ci.nsIWebProgress.NOTIFY_LOCATION |
                                 Ci.nsIWebProgress.NOTIFY_STATE_ALL);

        this.loading = false;

        scope = {};
        subscriptLoader.loadSubScript("chrome://songbird/content/bindings/browser/SBSessionStore.js", scope);
        this._sessionStore = scope.SBSessionStore;

        /* we want to know when the window has finished opening so we can
          restore tabs and other fun stuff
        */
        this.windowLoadEventListener = {
          tabbrowser: this,
          document: document,
          handleEvent: function sbTabBrowser_loadListener(event) {
            if (event.target != this.document) {
              return;
            }

            // Initialize the zoom manager
            FullZoom.init();

            this.tabbrowser._sessionStore.restoreTabState(this.tabbrowser);

            // *****************************
            // BUG 8097 - the tab strip is cut off when restoring with tabs
            var strip = this.tabbrowser.mStrip;
            if (!strip.hasAttribute("overflow")) {
              strip._arrowscrollbox.ensureElementIsVisible(strip._firstTab);
            }
            // *****************************

            // session restore has completed; focus the desired tab to select,
            // and dispatch an event notifying the end of the whole session
            // restore process.  However, since sbTabBrowser::loadURI will use
            // a setTimeout to focus the (effectively) last-opened tab, we need
            // to likewise use a setTimeout to focus the tab we want.
            setTimeout(function(aTabBrowser){
              var tab = aTabBrowser._tabToSelect;
              aTabBrowser._tabToSelect = null;
              aTabBrowser.selectedTab = tab;
              var event = document.createEvent("Events");
              event.initEvent("sessionstore-tabs-restored", true, false);
              aTabBrowser.dispatchEvent(event);
            }, 0, this.tabbrowser);
            window.removeEventListener('load', arguments.callee, true);
          }
        }
        window.addEventListener('load', this.windowLoadEventListener, true);

        this.windowUnloadEventListener = {
          tabbrowser: this,
          document: document,
          handleEvent: function sbTabBrowser_unloadListener(event) {
            if (event.target != this.document) {
              return;
            }

            // Shutdown the zoom manager
            FullZoom.destroy();

            // If we're stopped, then we need to stash whatever the user is looking at
            // so that the next view to load will use the same thing.
            if (this.tabbrowser.mm.status.state ==
                Ci.sbIMediacoreStatus.STATUS_STOPPED) {

              // If the current tab has a view then stash that.
              if (this.tabbrowser.mCurrentTab.mediaListView &&
                  this.tabbrowser.mCurrentTab.mediaListView.length > 0) {
                this.tabbrowser.mm.sequencer.view = this.tabbrowser.mCurrentTab.mediaListView;

              // Otherwise, use whatever is in the media tab (if we have one)
              } else if (this.tabbrowser.mediaTab &&
                         this.tabbrowser.mediaTab.mediaListView &&
                         this.tabbrowser.mediaTab.mediaListView.length > 0) {
                this.tabbrowser.mm.sequencer.view = this.tabbrowser.mediaTab.mediaListView;
              }
            }
          }
        }
        window.addEventListener('unload', this.windowUnloadEventListener, true);

        /* load the remote API handler bits
         * this provides the onRemoteAPI() method that is pretty self-contained
         * which is then triggered by the "remoteapi" DOM event.  It is used to
         * let the user accept remote API requests (currently, as a notification
         * box)
         */
        scope = {};
        subscriptLoader.loadSubScript("chrome://songbird/content/bindings/browser/SBRemoteAPIHandler.js", scope);
        this.onRemoteAPI = scope.onRemoteAPI;
        window.addEventListener("remoteapi", this.onRemoteAPI, true);

        // tell appshell how to open new tabs (sb bug 3757)
        scope = {};
        subscriptLoader.loadSubScript("chrome://songbird/content/bindings/browser/BrowserDOMWindow.js", scope);
        window.QueryInterface(Ci.nsIDOMChromeWindow).browserDOMWindow =
          new scope.BrowserDOMWindow(this);

        this.selectedBrowser.webNavigation.sessionHistory =
            Cc["@mozilla.org/browser/shistory;1"]
              .createInstance(Ci.nsISHistory);
        this.browsers[0].removeAttribute("disablehistory");

        // add a service pane listener to keep in sync with changes there
        // for example, if a playlist is renamed, if there are open tabs for that playlist
        // they should be retitled.
        var self = this;
        this._servicePaneService =
              Cc['@songbirdnest.com/servicepane/service;1']
                .getService(Ci.sbIServicePaneService);
        this._servicePaneListener = {
          attrModified: function(aNode, aAttrName, aNamespace, aOldVal, aNewVal) {
            if (aNamespace != null ||
                (aAttrName != 'class' &&
                 aAttrName != 'name' &&
                 aAttrName != 'image')) {
              // we only care about class name and image changing
              return;
            }

            // go through the tabs
            var tab = self.tabContainer.firstChild;
            while(tab) {
              // looking for one associated with the node that changed
              if (tab.servicePaneNode == aNode) {
                // and apply its properties
                tab.applyPropertiesFromServicePaneNode();
              }
              tab = tab.nextSibling;
            }
          },
          nodeInserted: function() {},
          nodeRemoved: function() {},
          QueryInterface: XPCOMUtils.generateQI([Ci.sbIServicePaneMutationListener])
        }
        this._servicePaneService.root.addMutationListener(this._servicePaneListener);

        this.mm = Cc["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Ci.sbIMediacoreManager);

        this.typeSniffer =
              Cc["@songbirdnest.com/Songbird/Mediacore/TypeSniffer;1"]
                .createInstance(Ci.sbIMediacoreTypeSniffer);

        // Add a observer to listen for shutdown to save tab state.
        var shutdownListener = {
          tabBrowser: self,

          observe: function(aSubject, aTopic, aData) {
            if (aTopic == "quit-application-granted") {
              this.tabBrowser._sessionStore.saveTabState(this.tabBrowser);

              var observerService = Cc["@mozilla.org/observer-service;1"]
                                      .getService(Ci.nsIObserverService);
              observerService.removeObserver(this, "quit-application-granted");
            }
          }
        };

        var observerService = Cc["@mozilla.org/observer-service;1"]
                                .getService(Ci.nsIObserverService);
        observerService.addObserver(shutdownListener, "quit-application-granted", false);

      ]]></constructor>
      <destructor>
        <![CDATA[

        // remove service pane listener
        this._servicePaneService.root.removeMutationListener(this._servicePaneListener);
        this._servicePaneService = null;

        this.removeProgressListener(this);

        window.removeEventListener('load', this.windowLoadEventListener, true);
        window.removeEventListener('unload', this.windowUnloadEventListener, true);

        window.removeEventListener("remoteapi", this.onRemoteAPI, true);
        window.QueryInterface(Ci.nsIDOMChromeWindow)
              .browserDOMWindow = null;

        this.mm = null;
        this.typeSniffer = null;
      ]]></destructor>

      <field name="_sessionStore">null</field>
      <field name="_servicePaneService">null</field>
      <field name="_servicePaneListener">null</field>

      <property name="tabStrip" readonly="true">
        <getter>return this.mStrip;</getter>
      </property>

      <!-- Override tabBrowser.setTabTitle in order to support
           service pane icons and titles for chrome URLs -->
      <method name="setTabTitle">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            var browser = this.getBrowserForTab(aTab);
            var crop = "end";
            var title = browser.contentTitle;

            if (!title) {
              if (browser.currentURI.spec) {
                // There is no title, fall back to the URI of the page
                try {
                  title = this.mURIFixup.createExposableURI(browser.currentURI).spec;
                } catch(ex) {
                  title = browser.currentURI.spec;
                }

                // At this point, we now have a URI.
                // Let's try to unescape it using a character set
                // in case the URI is not ASCII.
                try {
                  var characterSet = browser.contentDocument.characterSet;
                  const textToSubURI = Cc["@mozilla.org/intl/texttosuburi;1"]
                                         .getService(Ci.nsITextToSubURI);
                  title = textToSubURI.unEscapeNonAsciiURI(characterSet, title);
                } catch(ex) { /* Do nothing. */ }

                crop = "center";
              }

              if (!title || browser.currentURI.spec == "about:blank") {
                // still no title, use the localized text for untitled
                title = this.mStringBundle.getString("tabs.untitled");
              }
            }

            aTab.label = title;
            aTab.setAttribute("crop", crop);
          ]]>
        </body>
      </method>

      <!-- Override tabBrowser.updateCurrentBrowser to set focus correctly
        (http://bugzilla.songbirdnest.com/show_bug.cgi?id=21236) -->
      <method name="updateCurrentBrowser">
        <body>
          <![CDATA[
            var newBrowser = this.getBrowserAtIndex(this.mTabContainer.selectedIndex);
            if (this.mCurrentBrowser == newBrowser)
              return;

            if (this.mCurrentBrowser) {
              // Only save the focused element if it is in our content window
              // or in an ancestor window.
              var focusedWindow = document.commandDispatcher.focusedWindow;
              var saveFocus = false;

              if (focusedWindow && focusedWindow.top == window.content) {
                saveFocus = true;
              } else {
                var contentWindow = window;

                while (contentWindow) {
                  if (contentWindow == focusedWindow) {
                    saveFocus = true;
                    break;
                  }

                  if (contentWindow.parent == contentWindow) {
                    break;
                  }

                  contentWindow = contentWindow.parent;
                }
              }

              if (saveFocus) {
                // Preserve the currently-focused element or DOM window for
                // this tab.

                this.mCurrentBrowser.focusedWindow = focusedWindow;
                this.mCurrentBrowser.focusedElement = document.commandDispatcher.focusedElement;
              }

              if (this.mCurrentBrowser.focusedElement) {
                // Clear focus outline before we draw on top of it
                this.mCurrentBrowser.focusedElement.blur();
              }
              this.mCurrentBrowser.setAttribute("type", "content-targetable");
            }

            var updatePageReport = false;
            if ((this.mCurrentBrowser.pageReport && !newBrowser.pageReport) ||
                (!this.mCurrentBrowser.pageReport && newBrowser.pageReport))
              updatePageReport = true;

            newBrowser.setAttribute("type", "content-primary");
            this.mCurrentBrowser = newBrowser;
            this.mCurrentTab = this.selectedTab;

            if (updatePageReport)
              this.mCurrentBrowser.updatePageReport();

            // Update the URL bar.
            var loc = this.mCurrentBrowser.currentURI;

            // Update the busy state before notifying progress listeners.
            var prevIsBusy = this.mIsBusy;
            this.mIsBusy = this.mCurrentTab.hasAttribute("busy");

            var webProgress = this.mCurrentBrowser.webProgress;
            var securityUI = this.mCurrentBrowser.securityUI;

            var i, p;
            for (i = 0; i < this.mProgressListeners.length; i++) {
              p = this.mProgressListeners[i];
              if (p) {
                p.onLocationChange(webProgress, null, loc);
                if ('onLinkIconAvailable' in p)
                  p.onLinkIconAvailable(this.mCurrentBrowser);
                if (securityUI)
                  p.onSecurityChange(webProgress, null, securityUI.state);

                // make sure that all status indicators are properly updated
                if ("onUpdateCurrentBrowser" in p) {
                  var listener = this.mTabListeners[this.mTabContainer.selectedIndex] || null;
                  if (listener && listener.mStateFlags)
                    p.onUpdateCurrentBrowser(listener.mStateFlags, listener.mStatus,
                                             listener.mMessage, listener.mTotalProgress);
                }
              }
            }

            this._fastFind.setDocShell(this.mCurrentBrowser.docShell);

            // Update the window title.
            this.updateTitlebar();

            // If the new tab is busy, and our previous state was not busy, then
            // we need to fire a start to all progress listeners.
            const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
            if (this.mCurrentTab.hasAttribute("busy") && !prevIsBusy) {
              webProgress = this.mCurrentBrowser.webProgress;
              for (i = 0; i < this.mProgressListeners.length; i++) {
                p = this.mProgressListeners[i];
                if (p)
                  p.onStateChange(webProgress, null, nsIWebProgressListener.STATE_START | nsIWebProgressListener.STATE_IS_NETWORK, 0);
              }
            }

            // If the new tab is not busy, and our previous state was busy, then
            // we need to fire a stop to all progress listeners.
            if (!this.mCurrentTab.hasAttribute("busy") && prevIsBusy) {
              webProgress = this.mCurrentBrowser.webProgress;
              for (i = 0; i < this.mProgressListeners.length; i++) {
                p = this.mProgressListeners[i];
                if (p)
                  p.onStateChange(webProgress, null, nsIWebProgressListener.STATE_STOP | nsIWebProgressListener.STATE_IS_NETWORK, 0);
              }
            }

            // We've selected the new tab, so go ahead and notify listeners.
            var event = document.createEvent("Events");
            event.initEvent("TabSelect", true, false);
            this.mCurrentTab.dispatchEvent(event);

            if (document.commandDispatcher.focusedElement &&
                document.commandDispatcher.focusedElement.parentNode ==
                this.mCurrentTab.parentNode) {
              // The focus is on a tab in the same tab panel
              return;  // If focus was on a tab, switching tabs focuses the new tab
            }

            var whatToFocus = window.content;
            // The original code in tabBrowser.xml had some code to focus the previously focused
            // element or window, which isn't what we want for Songbird.  See bug 21236.

            var cmdDispatcher = document.commandDispatcher;

            if (whatToFocus instanceof Window) {
              cmdDispatcher.focusedWindow = whatToFocus;
              cmdDispatcher.focusedElement = null;
            } else {
              cmdDispatcher.focusedWindow = whatToFocus.ownerDocument.defaultView;
              cmdDispatcher.focusedElement = whatToFocus;
            }

            // Removed setTimeout based on
            // http://bonsai.mozilla.org/cvsblame.cgi?file=mozilla/browser/base/content/tabbrowser.xml&rev=1.271#847
          ]]>
        </body>
      </method>

      <method name="_checkTarget">
        <parameter name="aTarget"/>
        <parameter name="aEvent"/>
        <body>
          <![CDATA[
            var returnValue = aTarget;

            if ("_media" == aTarget) {
              if (this.mediaTab) {
                // force media things in the media tab
                return "_media";
              } else {
                // there's no media tab
                returnValue = "_top";
              }
            }

            if (aEvent) {
              // if an event as supplied infer where we want to load this URI
              //
              var isMac = window.navigator.platform.match(/^Mac/) == 'Mac';
              var middleButton = aEvent?(aEvent.button == 1):false;
              var newTabKey = aEvent ?
                               ((isMac?aEvent.metaKey:aEvent.ctrlKey) ||
                                aEvent.shiftKey)
                               : false;
              var saveKey = aEvent ? aEvent.altKey : false;
              if (middleButton || newTabKey) {
                returnValue = "_blank";
              } else if (saveKey) {
                returnValue = "_save";
              }
            }

            // check to see if tabs are allowed
            if (returnValue == '_blank' &&
                !this.mPrefs.getBoolPref('browser.tabs.enabled')) {
              returnValue = '_top';
            }

            return returnValue;
          ]]>
        </body>
      </method>

      <!-- the public interface for loading URLs.
           this overrides the implementation in tabBrowser.xml#tabbrowser
           it takes the existing aURI, aReferrerURI and aCharset arguments
           and optionally an aEvent and aMediaListView.

           aMediaListView will be provided to the tab and used if a
           media page or web playlist is loaded.
           -->
      <method name="loadURI">
        <parameter name="aURI"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <parameter name="aEvent"/>
        <parameter name="aDefaultLocation"/>
        <parameter name="aMediaListView"/>
        <body>
          <![CDATA[

            // If this is a request for the old sbLibaryPage
            // redirect it to the new page showing the main library
            // TODO delete this post 0.5
            if (aURI && aURI.indexOf &&
                aURI.indexOf("chrome://songbird/content/xul/sbLibraryPage.xul") == 0)
            {
              Cu.reportError("TabBrowser.loadURI was called for" +
                    " sbLibraryPage.xul! Use gBrowser.loadMediaList instead.");

              this.loadMediaList(LibraryUtils.mainLibrary, aEvent,
                    aDefaultLocation);
              return;
            }


            var retval = null;
            var defaultLocation = aDefaultLocation;
            if (!defaultLocation) {
              defaultLocation = "_top";
            }
            var where = this._checkTarget(defaultLocation, aEvent);


            // make sure the referrer is an nsIURI
            if (aReferrerURI == '') {
              aReferrerURI = null;
            } else {
              if (typeof(aReferrerURI) == 'string') {
                aReferrerURI = (Cc["@mozilla.org/network/io-service;1"]
                                  .getService(Ci.nsIIOService)
                                  .newURI(aReferrerURI, aCharset, null));
              }
            }

            // if we plan on opening it in the media tab, find it
            if (this.mediaTab) {
              if (where == "_media") {
                where = this.mediaTab;
              } else if ("_top" == where &&
                         this.selectedTab == this.mediaTab) {
                // always open a new tab if currently on the media tab
                where = "_blank";
              }
            }

            // Now, actually open the URI
            if (where == "_blank") {
              retval = this._loadMediaListViewInternal(aURI,
                                                       null,
                                                       aReferrerURI,
                                                       aCharset,
                                                       aMediaListView);
            } else if (where == "_top") {
              retval = this._loadMediaListViewInternal(aURI,
                                                       this.mCurrentTab,
                                                       aReferrerURI,
                                                       aCharset,
                                                       aMediaListView);
            // If aDefaultLocation is a tab, load there
            } else if (where && where.linkedBrowser) {
              retval = this._loadMediaListViewInternal(aURI,
                                                       where,
                                                       aReferrerURI,
                                                       aCharset,
                                                       aMediaListView);
            } else if (where == "_save") {
              saveURL(aURI, null, null, true, null, aReferrerURI);
            } else {
              // eek! unknown target
            }
            return retval;
          ]]>
        </body>
      </method>

      <!-- Load a media list view with flags -->
      <method name="loadMediaListViewWithFlags">
        <parameter name="aMediaListView"/>
        <parameter name="aTab"/>
        <parameter name="aPageURL"/>
        <parameter name="aFlags"/>
        <parameter name="aLoadInBackground"/>
        <body>
          <![CDATA[
            var pageURL = this._getMediaPageURL(aMediaListView, aPageURL);
            var bgLoad = (aLoadInBackground != null) ? aLoadInBackground :
                          this.mPrefs.getBoolPref("browser.tabs.loadInBackground");
            const sbIMediaListView = Ci.sbIMediaListView;
            if (!aMediaListView || !(aMediaListView instanceof sbIMediaListView)) {
              Cu.reportError(new Exception('Attempting to load invalid media list view',
                                           Cr.NS_ERROR_INVALID_ARG));
              var url = "about:neterror?e=malformedURI&u=" + encodeURIComponent(aPageURL);
              if (aTab) {
                aTab.linkedBrowser.loadURIWithFlags(url, aFlags);
              } else {
                this.loadOneTab(url, null, null, null, bgLoad, null);
              }
            }
            return this._loadMediaListViewInternal(pageURL,
                                                   aTab,
                                                   null,
                                                   null,
                                                   aMediaListView,
                                                   aFlags,
                                                   bgLoad);
          ]]>
        </body>
      </method>

      <!-- Helper to load a media list into a given tab
           @param aTab the <tab> to load into; null to load in a new tab
           @param aURI the URI to load
           @param aReferrerURI the referrer (may be null)
           @param aCharset the charset (may be null)
           @param aMediaListView the media list view to load
           @param aFlags flags for the load (doesn't apply to new tabs)
           @param aLoadInBackground specify to load this tab in the background
                    uses loaInBackground pref if null.
           -->
      <method name="_loadMediaListViewInternal">
        <parameter name="aURI"/>
        <parameter name="aTab"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <parameter name="aMediaListView"/>
        <parameter name="aFlags"/>
        <parameter name="aLoadInBackground"/>
        <body>
          <![CDATA[
            var tab = aTab;
            if (!aFlags) {
              aFlags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
            }
            var bgLoad = (aLoadInBackground != null) ? aLoadInBackground :
                          this.mPrefs.getBoolPref("browser.tabs.loadInBackground");
            if (tab) {
              tab.linkedBrowser.loadURIWithFlags(aURI, aFlags, aReferrerURI, aCharset);
              if (!bgLoad)
                this.selectedTab = tab;
            } else {
              tab = this.loadOneTab(aURI, aReferrerURI, aCharset, null, bgLoad, null);
            }
            tab._viewForPage = aMediaListView;
            if (tab._viewForPage)
              tab._isNewViewForPage = true;
            return tab;
          ]]>
        </body>
      </method>

      <!-- Get the media page URL for a media list
           @param aMediaListView the media list View to look up
           @param aPageURL       [optional] a suggested URL
           @param aConstraints   [optional] A constrain used as an additional
                                            matching criteria
        -->
      <method name="_getMediaPageURL">
        <parameter name="aMediaListView"/>
        <parameter name="aPageURL"/>
        <parameter name="aConstraints"/>
        <body>
          <![CDATA[
            var mgr = Cc["@songbirdnest.com/Songbird/MediaPageManager;1"]
                        .getService(Ci.sbIMediaPageManager);

            var pageURL = null;
            var mediaList = null;
            if (aMediaListView instanceof Ci.sbIMediaListView) {
              mediaList = aMediaListView.mediaList;
            }
            else if (aMediaListView instanceof Ci.sbIMediaList) {
              // Fallback for obsolete API
              mediaList = aMediaListView;
            }

            // If a page URL was provided, confirm that it is allowed for this medialist
            if (aPageURL) {
              var found = false;
              for each (var page in ArrayConverter.JSEnum(
                                        mgr.getAvailablePages(mediaList))) {
                page.QueryInterface(Ci.sbIMediaPageInfo);
                if (aPageURL.indexOf(page.contentUrl) == 0) {
                  pageURL = aPageURL;
                  break;
                }
              }
            }

            var LSP = Cc["@songbirdnest.com/servicepane/library;1"]
                        .getService(Ci.sbILibraryServicePaneService);
            var type = LSP.getNodeContentTypeFromMediaListView(aMediaListView);

            // If no URL, get the default from the page manager
            if (!pageURL) {
              var page = mgr.getPage(mediaList, aConstraints, type);
              pageURL = page.contentUrl;
            }

            // If not already present, attach the guids to the querystring
            // so that the page gets a unique browser history entry.
            // I would have preferred to use a # instead of a querystring,
            // but anchors are ignored in loadURI.
            if (pageURL.indexOf("libraryGUID=") == -1) {
              if (pageURL.indexOf("?") != -1) {
                pageURL += "&";
              } else {
                pageURL += "?";
              }
              pageURL += "libraryGUID=" + escape(mediaList.library.guid) +
                         "&listGUID=" + escape(mediaList.guid);
            }

            return pageURL;
          ]]>
        </body>
      </method>

      <!-- override <tabbrowser>::removeTab to prevent the media tab from being
           removed
           -->
      <method name="removeTab">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            if (aTab == this.mediaTab) {
              return;
            }
            var proto = this;
            while (proto && ("removeTab" in proto) && proto.removeTab == this.removeTab) {
              proto = proto.__proto__;
            }
            if (proto)
              return proto.removeTab.apply(this, arguments);
            return;
          ]]>
        </body>
      </method>

      <!-- Use a Media Page to display the given list and
           (optional) view.
        -->
      <method name="loadMediaList">
        <parameter name="aMediaList"/>
        <parameter name="aEvent"/>
        <parameter name="aDefaultLocation"/>
        <parameter name="aMediaListView"/>
        <parameter name="aPageURL"/>
        <parameter name="aForcePageURL"/>
        <body>
          <![CDATA[
            // If we weren't passed a view, create one
            if (aMediaListView == null) {
              aMediaListView =
                LibraryUtils.createStandardMediaListView(aMediaList);
            }

            if (!aForcePageURL) {
              aPageURL = this._getMediaPageURL(aMediaListView,
                                               aPageURL,
                                               aMediaListView.filterConstraint);
            }

            // if no default location specified, load in the media tab (if available)
            var defaultLocation = aDefaultLocation;
            if (!defaultLocation && this.mediaTab)
              defaultLocation = "_media";

            return this.loadURI(aPageURL, null, null, aEvent,
                                defaultLocation, aMediaListView);
          ]]>
        </body>
      </method>


      <!-- Reveal the given index in the given sbIMediaListView  -->
      <method name="showIndexInView">
        <parameter name="aMediaListView"/>
        <parameter name="aHighlightIndex"/>
        <body>
          <![CDATA[
            if (!(aMediaListView instanceof Ci.sbIMediaListView) ||
                !(aHighlightIndex >= 0)) {
              throw new Error("showIndexInView requires a media list view and index");
            }

            // If we already have a tab for this view, show it there
            var tab = this.getTabForView(aMediaListView);
            if (tab) {
              this.selectedTab = tab;
              if (tab.mediaPage) {
                tab.mediaPage.highlightItem(aHighlightIndex);
              } else if (tab.outerPlaylist) {
                var tree = tab.outerPlaylist.tree;
                tree.treeBoxObject.ensureRowIsVisible(aHighlightIndex);
                tree.view.selection.select(aHighlightIndex);
              }

            // Not already visible.  Load and highlight.
            } else {
              // If the view is for a web media list, load the origin page.
              // Otherwise, load the media list.
              var mediaList = aMediaListView.mediaList;
              if (mediaList.library.equals(LibraryUtils.webLibrary) &&
                  (mediaList.getProperty(SBProperties.isList) == "1"))
              {
                aMediaListView.selection.selectOnly(aHighlightIndex);
                var originPage = mediaList.getProperty(SBProperties.originPage);
                tab = this.loadURI(originPage, null, null, null, null,
                                   aMediaListView);
              } else {
                aMediaListView.selection.selectOnly(aHighlightIndex);
                tab = this.loadMediaList(aMediaListView.mediaList, null,
                                         null, aMediaListView);
              }
            }
          ]]>
        </body>
      </method>


      <!-- Get the web playlist for the current tab -->
      <property name="currentOuterPlaylist" readonly="true"
                onget="return this.mCurrentTab.outerPlaylist" />

      <!-- Get the sbIMediaPage for the current tab -->
      <property name="currentMediaPage" readonly="true"
                onget="return this.mCurrentTab.mediaPage" />

      <!-- Get the sbIMediaListView for the current tab.
           May come from the web playlist or media page. -->
      <property name="currentMediaListView" readonly="true"
                onget="return this.mCurrentTab.mediaListView" />

      <field name="_loading">SB_NewDataRemote("faceplate.loading", null)</field>
      <property name="loading"
                onget="return this._loading.boolValue"
                onset="this._loading.boolValue = val;" />

      <method name="getTabForView">
        <parameter name="aView" />
        <body><![CDATA[
          // Search open tabs for an sbIMediaListView that is showing the given view
          var tabs = this.mTabs;
          var tab;
          for (var i = 0; i < tabs.length; i++) {
            tab = tabs[i];
            if (tab.mediaListView && tab.mediaListView == aView) {
              return tab;
            }
          }
          return null;
        ]]></body>
      </method>

      <!-- Sends a "TabContentChange" event from the current tab.
           Called when the user switches tabs, and before and after
           a new page is loaded in the current tab.

           Use this event if you want to track what the user is
           viewing in the tab browser.

           This event is needed because:
             * nsIWebProgressListener does not provide access to
               the changing tab
             * "load" is dispatched only for tab favicons
             * "TabSelect" is dispatched only on tab change, not on
                new content
       -->
      <method name="notifyTabContentChange">
        <body>
        <![CDATA[
          // Update the loading status of the web-toolbar items:
          this.loading = this.mIsBusy;

          var event = document.createEvent("Events");
          event.initEvent("TabContentChange", true, false);
          this.dispatchEvent(event);

          this._updateFindbarState();

          document.commandDispatcher.updateCommands("tabchange");

          // Update the edit menu since the content has changed in the tab:
          document.commandDispatcher.updateCommands("focus");
        ]]></body>
      </method>

      <method name="_updateFindbarState">
        <body>
          <![CDATA[
            // If we are about to show a media page, let's supress the findbar.
            if (this.shouldDisableFindAgainForSelectedTab() &&
                !this.isFindbarHidden)
            {
              // Calling |closeFindbar()| simply hides the findbar from
              // the content view and saves the contents of the search.
              this.closeFindbar();
              this._mFindbarIsSuppressed = true;
            }
            else if (!this.shouldDisableFindAgainForSelectedTab() &&
                     this._mFindbarIsSuppressed)
            {
              // Now the tab content that we are switching to is not a media page
              // and we have suppressed the findbar - it's time to show it now.
              this.showFindbar();
              this._mFindbarIsSuppressed = false;
            }
          ]]>
        </body>
      </method>

      <!-- Whether "Find" should be disabled for the selected tab -->
      <method name="shouldDisableFindForSelectedTab">
        <body>
          <![CDATA[
            if (this.mediaTab &&
                this.selectedTab == this.mediaTab &&
                this.selectedTab.mediaPage == null) {
              return true;
            }
          ]]>
        </body>
      </method>

      <!-- Whether "Find Again" should be disabled for the selected tab -->
      <method name="shouldDisableFindAgainForSelectedTab">
        <body>
          <![CDATA[
            if (this.mediaTab && this.selectedTab == this.mediaTab) {
              return true;
            }
            return this.selectedTab &&
                   this.selectedTab.mediaPage != null;
          ]]>
        </body>
      </method>

      <!-- a bunch of methods from browser_xbl_temp.js / songbird_hack.js.
           I'm not convinced they belong here, but till we refactor a couple
           more things there's nowhere better for them to go. -->

      <!-- Handles playing the given URL by adding it to the web
           library, and if possible playing it from the current
           web playlist.
        -->
      <method name="_playExternalUrl">
        <parameter name="aURL" />
        <parameter name="aTryWeb" />
        <body>
            <![CDATA[

          // figure out if the url is in the webplaylist
          var currentPlaylist = this.currentOuterPlaylist;
          var sequencer = this.mm.sequencer;

          if (aTryWeb && currentPlaylist)
          {
            var currentView = currentPlaylist.getListView();

            // Try to see if we've already found and scanned this url
            var listener = {
              foundItem: null,
              onEnumerationBegin: function onEnumerationBegin() {
                if (this.foundItem) {
                  return Ci.sbIMediaListEnumerationListener.CANCEL;
                }
                else {
                  return Ci.sbIMediaListEnumerationListener.CONTINUE;
                }
              },
              onEnumeratedItem: function onEnumeratedItem(list, item) {
                this.foundItem = item;
                return Ci.sbIMediaListEnumerationListener.CANCEL;
              },
              onEnumerationEnd: function onEnumerationEnd() {
              }
            };

            var currentMediaList = currentView.mediaList;

            currentMediaList.enumerateItemsByProperty(SBProperties.originURL, aURL, listener );
            currentMediaList.enumerateItemsByProperty(SBProperties.contentURL, aURL, listener );

            if (listener.foundItem) {
              sequencer.playView(currentView,
                                 currentView.getIndexForItem(listener.foundItem));
              return;
            }
          }

          // otherwise, play the url as external (added to the db,
          // plays the library from that point on)
          // if the url is already in the lib, it is not added twice
          var item = SBImportURLIntoWebLibrary(aURL);

          var view = LibraryUtils.createStandardMediaListView(LibraryUtils.webLibrary);

          var index = view.getIndexForItem(item);

          // If we have a browser, try to show the view
          if (window.gBrowser) {
            gBrowser.showIndexInView(view, index);
          }

          // Play the item
          sequencer.playView(view, index);
        ]]></body>
      </method>


      <!-- Called when the user clicks on a media URL in a web page.
           Handles playing from the web playlist, opening as a playlist, etc.
        -->
      <method name="handleMediaURL">
        <parameter name="aURL" />
        <parameter name="aShouldBeginPlayback" />
        <parameter name="forcePlaylist" />
        <body>
                      <![CDATA[
          var retval = false;
          var tab = this.selectedTab;
          try
          {
            var ioService = Cc["@mozilla.org/network/io-service;1"]
                              .getService(Ci.nsIIOService);
            var uri;
            try {
              uri = ioService.newURI(aURL, null, null);
            }
            catch(e) {
            }

            // Stick playlists in the service pane (for now).
            if ( uri && (forcePlaylist || this.typeSniffer.isValidWebSafePlaylistURL( uri )) )
            {
              var library = null;
              var scheme = uri.scheme;

              if ( scheme != "file" &&
                   scheme != "resource" &&
                   scheme != "chrome" &&
                   scheme != "jar" ) {
                library = LibraryUtils.webLibrary;
              }
              else {
                library = Cc["@songbirdnest.com/Songbird/library/Manager;1"]
                            .getService(Ci.sbILibraryManager).mainLibrary;
              }

              // Check to see if this playlist already exists
              var propertyArray =
                Cc["@songbirdnest.com/Songbird/Properties/MutablePropertyArray;1"]
                  .createInstance(Ci.sbIMutablePropertyArray);
              propertyArray.appendProperty(SBProperties.isList, "1");
              propertyArray.appendProperty(SBProperties.originURL, uri.spec);

              var getFirstListener = {
                item: null,
                onEnumerationBegin: function() {
                },
                onEnumeratedItem: function(list, item) {
                  this.item = item;
                  return Ci.sbIMediaListEnumerationListener.CANCEL;
                },
                onEnumerationEnd: function() {
                }
              };

              library.enumerateItemsByProperties(propertyArray,
                                                 getFirstListener );

              // If we found a matching list, clear it, otherwise create it
              var mediaList = null;
              var mediaListView = null;
              if (getFirstListener.item) {
                mediaList = getFirstListener.item;
                mediaList.clear();
              }
              else {
                if ( scheme == "http" ) {
                  mediaList = tab.outerPlaylist.mediaList;
                  mediaListView = tab.outerPlaylist.getListView();

                  if (mediaList) {
                    mediaList.clear();
                    tab.outerPlaylistShowing = true;
                    var locationBar = document.getElementById("location_bar");
                    locationBar.uri = aURL;
                  }
                }

                if (!mediaList) {
                  mediaList = library.createMediaList("simple");

                  mediaList.name = URLUtils.convertURLToDisplayName(aURL);

                  mediaList.setProperty("http://songbirdnest.com/data/1.0#originURL", uri.spec);
                }
              }

              var playlistReaderManager =
                Cc["@songbirdnest.com/Songbird/PlaylistReaderManager;1"]
                  .getService(Ci.sbIPlaylistReaderManager);
              var playlistReaderListener =
                Cc["@songbirdnest.com/Songbird/PlaylistReaderListener;1"]
                  .createInstance(Ci.sbIPlaylistReaderListener);

              // Create this closure here to prevent this object from getting garbage
              // collected too soon.  The playlist reader uses the nsIWebBrowserPersist
              // component that does _not_ addref this listener :(
              var self = this;

              var playlist_observer = {
                mm: self.mm,
                observe: function ( aSubject, aTopic, aData ) {
                  if (aTopic.indexOf("error") != -1) {
                    // If we get an error parsing a page we thought was a
                    // playlist then we probably misidentified the content.
                    Cu.reportError("Failed to parse playlist at " + aURL);
                  }
                  else {
                    var array =
                      Cc["@songbirdnest.com/moz/xpcom/threadsafe-array;1"]
                        .createInstance(Ci.nsIMutableArray);
                    for (var i = 0; i < mediaList.length; i++) {
                      array.appendElement(mediaList.getItemByIndex(i), false);
                    }

                    // Send the items in the new media list to the metadata scanner
                    var metadataService =
                      Cc["@songbirdnest.com/Songbird/FileMetadataService;1"]
                        .getService(Ci.sbIFileMetadataService);
                    metadataService.read(array);

                    // Start playback
                    var view = tab.mediaListView;
                    if ((!view) || (view.mediaList != mediaList)) {
                      view = mediaList.createView();
                    }

                    this.mm.sequencer.playView(view, 0);
                  }
                }
              };

              playlistReaderListener.playWhenLoaded = aShouldBeginPlayback;
              playlistReaderListener.observer = playlist_observer;
              playlistReaderListener.mediaMimetypesOnly = true;
              playlistReaderManager.originalURI = uri;
              playlistReaderManager.loadPlaylist(uri, mediaList, null, false, playlistReaderListener);
              retval = true;
            }
            // Everything else gets played directly.
            else if ( this.typeSniffer.isValidMediaURL( uri ) )
            {
              this._playExternalUrl(aURL, true);
              retval = true;
            }
          }
          catch ( err )
          {
            alert("sb-tabbrowser::handleMediaURL(" + aURL + "); " + err );
          }
          return retval;
        ]]></body>
      </method>

      <!--
        Show a notification message.  If the given notification already exists
        (but not necessarily shown), show it with an updated message.  Note that
        only the message (and not the icon, priority, or buttons) get updated.
        -->
      <method name="showNotification">
        <parameter name="aBrowser"/>
        <parameter name="aNotificationName"/>
        <parameter name="aMessage"/>
        <parameter name="aIconURL"/>
        <parameter name="aPriority"/>
        <parameter name="aButtons"/>
        <body><![CDATA[
          var browser = aBrowser;
          if (aBrowser instanceof Document) {
            // given a document; find the containing <browser> instead
            browser = this.getBrowserForDocument(aBrowser);
          } else if (aBrowser instanceof Ci.nsIDocShell) {
            // given a random docshell, try to find a <browser> that holds
            // an ancestor
            for (var i = 0; i < this.browsers.length; ++i) {
              // walk up the docshell tree to see if the <browser> we have is a parent
              var targetDocShell = aBrowser.QueryInterface(Ci.nsIDocShellTreeItem);
              browser = this.getBrowserAtIndex(i);
              while (targetDocShell && browser.docShell != targetDocShell) {
                targetDocShell = targetDocShell.parent;
              }
              if (browser.docShell == targetDocShell)
                break;
              browser = null;
            }
          }
          if (!browser) {
            throw Ci.NS_ERROR_INVALID_ARG;
          }

          var notificationBox = this.getNotificationBox(browser);
          var notification = notificationBox
                                   .getNotificationWithValue(aNotificationName);
          if (!notification) {
            // if there isn't a notification object, make one and append it
            notification = notificationBox.appendNotification(aMessage,
                                                              aNotificationName,
                                                              aIconURL,
                                                              aPriority,
                                                              aButtons);
          } else {
            // if there is a notification object set it's text.
            // this has the side effect of showing it if it was dismissed
            notification.message = aMessage;
          }
          return notification;
        ]]></body>
      </method>

      <!-- sbITabBrowser -->
      <method name="getTabForDocument">
        <parameter name="aDocument" />
        <body><![CDATA[
          var numTabs = this.mTabs.length;
          for ( var index = 0; index < numTabs; index++ ) {
            if ( this.mTabs[index]
                     .linkedBrowser
                     .contentDocument == aDocument ) {
              return this.mTabs[index];
            }
          }
          return null;
        ]]></body>
      </method>

      <!-- media tab handling -->
      <property name="mediaTab">
        <getter><![CDATA[
          if (!this.hasAttribute("hasmediatab"))
            return null;
          return this.mTabs[0];
        ]]></getter>
      </property>
      <property name="_lastNonMediaTab">
        <getter>
          return this.mStrip.lastSelectedTab;
        </getter>
      </property>

      <field name="_popupShowing">false</field>
      <method name="onContextPopupShowing">
        <parameter name="popup" />
        <parameter name="event" />
        <body><![CDATA[
          window.gContextMenu = new ContentAreaContextMenu(popup, window.getBrowser());
          this._popupShowing = gContextMenu.shouldDisplay;
          return this._popupShowing;
        ]]></body>
      </method>

      <method name="onContextPopupHiding">
        <parameter name="popup"/>
        <body>
          <![CDATA[
          window.gContextMenu = null;
          this._popupShowing = false;
        ]]></body>
      </method>


      <!-- Override tabBrowser.xul homepage.  Uses mozilla.org by default -->
      <property name="homePage">
        <getter><![CDATA[
          return Application.prefs.get("browser.startup.homepage").value;
        ]]></getter>
        <setter><![CDATA[
          Application.prefs.setValue("browser.startup.homepage", val);
        ]]></setter>
      </property>
      <method name="goHome">
        <body><![CDATA[
          this.loadURI(this.homePage, null, null);
        ]]></body>
      </method>

      <!-- Override tabBrowser.xul to support moving the tab strip outside -->
      <method name="onTitleChanged">
        <parameter name="evt"/>
        <body>
          <![CDATA[
            /* |this| is the <browser> */
            if (evt.target != this.contentDocument)
              return;

            var tabBrowser = document.getBindingParent(this);

            var tab = document.getAnonymousElementByAttribute(tabBrowser, "linkedpanel", this.parentNode.id);
            if (!tab) {
              tab = tabBrowser.mTabContainer.getElementsByAttribute("linkedpanel", this.parentNode.id)[0];
            }
            tabBrowser.setTabTitle(tab);

            // Don't update titlebar on Mac (bug 21219)
            if (tabBrowser._platform != "Darwin" &&
                tab == tabBrowser.mCurrentTab)
            {
              tabBrowser.updateTitlebar();
            }
          ]]>
        </body>
      </method>

      <field name="_strip">
        document.getAnonymousElementByAttribute(this, "anonid", "tabcontainer");
      </field>
      <property name="mStrip">
        <setter>
          <![CDATA[
            // override the onerror attribute because it asks for binding parent
            function tab_onerror(event) {
              gBrowser.addToMissedIconCache(this.getAttribute('image'));
              this.setIcon(null);
            }

            if (!val) {
              throw Cr.NS_ERROR_INVALID_ARG;
            }
            // we can't just move stuff around the DOM, because then anonymous
            // nodes magically become real.  And breaks all sorts of things.
            var selectedTab = this.mTabBox.selectedTab;
            if (this._strip != val) {
              this._strip.collapsed = true;
              while (val.firstChild) {
                val.removeChild(val.firstChild);
              }
              while (this._strip.firstChild) {
                var tab = this._strip.firstChild;
                var linkedBrowser = tab.linkedBrowser;
                val.appendChild(tab);
                tab.setAttribute("onerror", "(" + uneval(tab_onerror) + ").call(this, event)");
                if (!(tab.linkedBrowser)) {
                  tab.linkedBrowser = linkedBrowser;
                }
              }
              this._strip.style.MozBinding = "";
            }
            this._strip = this.mTabContainer = val;
            val._tabbrowser = this; // setting the private property!
            this.mTabs = this.mTabContainer.childNodes;
            this.mTabBox._tabs = this.mTabContainer;
            this.mTabBox.selectedTab = selectedTab;
          ]]>
        </setter>
        <getter>
          return this._strip;
        </getter>
      </property>

      <!-- set the tab to select when loading is complete
        -  This will get called from the session restore (if it exists),
        -  and possibly from command-line handlers that feel like opening new
        -  tabs during startup (e.g. the protocol handler)
        -->
      <method name="delayedSelectTab">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            if (this._tabToSelect === null) {
              // already done loading
              this.mTabBox.selectedTab = aTab;
            } else {
              // wait to load things
              this._tabToSelect = aTab;
            }
          ]]>
        </body>
      </method>
      <field name="_tabToSelect"/> <!-- default to undefined -->
    </implementation>

    <handlers>
      <handler event="click" phase="bubbling">
            <![CDATA[
        // inspired by contentAreaClick in ffox browser.js
        if (!event.isTrusted || event.getPreventDefault()) {
          return true;
        }

        if (this._popupShowing || event.button == 2) {
          // if we're showing a popup or about to show one, let's do nothing
          return true;
        }

        var ioService = Cc["@mozilla.org/network/io-service;1"]
                          .getService(Ci.nsIIOService);

        var target = event.target;
        var linkNode = null;

        if (target instanceof HTMLAnchorElement ||
            target instanceof HTMLAreaElement ||
            target instanceof HTMLLinkElement) {
          if (target.hasAttribute("href")) {
            linkNode = target;
          }

          // backwards compat - use the outermost link node
          var parent = target.parentNode;
          while (parent) {
            if (parent instanceof HTMLAnchorElement ||
                parent instanceof HTMLAreaElement ||
                parent instanceof HTMLLinkElement) {
                if (parent.hasAttribute("href")) {
                  linkNode = parent;
                }
            }
            parent = parent.parentNode;
          }
        } else {
          linkNode = event.originalTarget;
          while (linkNode && !(linkNode instanceof HTMLAnchorElement)) {
            linkNode = linkNode.parentNode;
          }
          // <a> cannot be nested.  So if we find an anchor without an
          // href, there is no useful <a> around the target
          if (linkNode && !linkNode.hasAttribute("href")) {
            linkNode = null;
          }
        }

        var wrapper = null;
        var href = null;
        var target = null;

        if (linkNode) {
          href = linkNode.href;
          if (linkNode.hasAttribute('target')) {
            target = linkNode.getAttribute('target');
          }
        } else {
          // Try simple XLink
          var realHref, baseURI;
          linkNode = target;
          while (linkNode) {
            if (linkNode.nodeType == Node.ELEMENT_NODE) {
              wrapper = linkNode;

              realHref = wrapper.getAttributeNS("http://www.w3.org/1999/xlink", "href");
              if (realHref) {
                href = realHref;
                baseURI = wrapper.baseURI
              }
            }
            linkNode = linkNode.parentNode;
          }
          if (href) {
            var base = ioService.newURI(baseURI, null, null);
            href = ioService.newURI(base.resolve(href), null, null).spec;
          }
        }

        if (href) {
          // get the document that this event originated in
          var doc = event.target.ownerDocument;

          var secMan = Cc["@mozilla.org/scriptsecuritymanager;1"]
                         .getService(Ci.nsIScriptSecurityManager);
          secMan.checkLoadURIStrWithPrincipal(doc.nodePrincipal, href,
                     Ci.nsIScriptSecurityManager.STANDARD);

          // get the referrer if we can
          var referrer = doc ? doc.documentURIObject : null;

          // we need to handle playlists and media items specially
          if (this.handleMediaURL(href, false, false)) {
            event.preventDefault();
          } else {
            var where = this._checkTarget(target, event);
            if (where && this.loadURI(href, referrer, null, event, where)) {
              event.preventDefault();
            }
          }
        }
        return true;
      ]]></handler>
    </handlers>
  </binding>

</bindings>
